# Git  

Система управления версиями  
Мажорная.Минорная.Патч  

`Git branch`  Создание новой ветки  
`Git branch -a`  Посмотреть ветки  
`Git branch -D bugfix`  Удалить ветку  
`Git checkout` Переключиться (т.е. сместить указатель HEAD) на ветку или коммит. Файлы приводятся в соотв. состояние  
`Git checkout main^` Перемещение на одного родителя назад  
`Git checkout main^^` Перемещение на двух родителей назад  
`Git checkout main~7` Перемещение на 7 родителей назад  
`Git checkout -b newbranch` Создать ветку и переключиться на неё  
`Git merge targetBranch` Слияние ветки targetBranch в текущую. У коммита 2 родителя  
`Git rebase main`  Переместить текущие коммиты в main  
`Git reset`  Переместит указатель на родителя, как будто бы текущего коммита не было. Работает в локальном репозитории  
`Git revert`  Отменит изменения предыдущего коммита, записав при этом новый коммит. Работает в удалённых репозиториях  
`Git cherry-pick fee6 gh2e`  Скопировать 2 коммита в текущую ветку  
`Git rebase -i HEAD~4`  Интерактивный ребейз для последних 4 коммитов. Можно удалять или менять местами  
`Git tag`  Создание тага, на который можно ссылаться  
`Git pull`  По сути является двумя коммандами `git fetch` (скачивание изменений) и `git merge` (слияние изменений)  
`Pull request` вместо обычного `git push` если main ветка заблокирована политикой гита
Гит конфиг - систем, глобал, для проекта
Гит игнор
При совершении коммита вычисляется его хеш сумма, ссылка на предыдущий коммит, изменённая информация, метаданные  
При Git ADD файл попадает в стейдж (подготовленная к комиту зона, ещё говорят добавить в индекс)  
Гит лог выведет историю коммитов -p более подробно  
Гит show более подробная инфа  
Гит рестор - привести файлы к состоянию предыдущего коммита  
Git remote -v проверить ссылки на удалённые репозитории  
Git push --set-upstream origin main Связать локальную ветку с удалённой, что бы писать git push вместо git push origin main  
Git push --tags отправить теги (по умолчанию не отправляются)  





# Терминал  
mkdir /usr/local/src/bash/{old,new,dist,bugs} создаст 4 директории  
Конструкция [[ -d /tmp ]] проверяет наличие катаолга /tmp и возвращает 0 или 1  

man, grep, передача процесса из одной терминальной сессии в другую (reptyr и PID процесса), файловые дескрипторы  
stdin stdout stderr  

# Файловый дескриптор  
Файловый дескриптор — это число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом  
Дескриптор для каждого процесса является уникальным. Но есть три жестко закрепленных индекса — это первые три номера (0, 1, 2).  
0 — стандартный ввод (stdin), место, из которого программа получает интерактивный ввод.  
1 — стандартный вывод (stdout), на который направлена большая часть вывода программы.  
2 — стандартный поток ошибок (stderror), в который направляются сообщения об ошибках.  

Для чего нужны:  

Таблица файловых дескрипторов индексирует общесистемную таблицу файлов, открытых всеми процессами.  
В таблице файлов записывается режим, в котором открыт файл или другой ресурс — например, для чтения, записи, чтения и записи.  
Режим индексируется в таблицу индексных дескрипторов, описывающих фактические базовые файлы. В каждом индексном дескрипторе хранятся атрибуты и расположение дисковых блоков переданного объекта.

# Зомби процессы    
Каждая программа, которая выполняется в Linux, - это системный процесс, у которого есть свой идентификатор. Каждый процесс может запускать дочерние процессы с помощью функции fork. Такие процессы остаются под контролем родительского процесса и не могут быть завершены без его ведома. Если один из дочерних процессов всё же завершился, а его родительский процесс не смог получить об этом информацию, то такой дочерний процесс становится зомби.  

Зомби процессы Linux не выполняются и убить их нельзя, даже с помощью sigkill, они продолжают висеть в памяти, пока не будет завершён их родительский процесс.  

# Процесс-сирота  
процесс-сирота — это процесс, который остается неактивным или в рабочем состоянии даже после завершения своего родительского процесса

# Inode  
+ Inode - это структура данных в которой хранится информация о файле или директории в файловой системе. В файловой системе Linux, например Ext4, у файла есть не только само его содержимое, например, тот текст, но и метаданные, такие как дата создания, доступа, модификации и права. Вот эти метаданные и хранятся в Inode. У каждого файла есть своя уникальная Inode и именно здесь указано в каких блоках находятся данные файла.  
+ Если пишет "не хватает места на диске" но оно есть, возможно, закончились Inode.  
+ Нельзя изменить Inode в существующей файловой системе.  
+ Можно указать их количество при создании новой файловой системы или разметить её с меньшим объёмом блока (по умолчанию 4096).  



